import{s as Bt,u as v,a,n as S,l as $,o as d,b as p,c as I,_ as V,d as u,i as ht,r as b,e as T,p as pt,f as E,g as Zt,h as mt,j as Gt,k as ft,A as Kt,m as Yt,q as Xt,Z as es,N as ts,t as ss,v as rs,w as os,E as as}from"./vendor-misc-sHEHZw9n.js";function ge(r){return!!r._zod}function J(r,e){return ge(r)?Bt(r,e):r.safeParse(e)}function _t(r){var t,s;if(!r)return;let e;if(ge(r)?e=(s=(t=r._zod)==null?void 0:t.def)==null?void 0:s.shape:e=r.shape,!!e){if(typeof e=="function")try{return e()}catch{return}return e}}function ns(r){var o;if(ge(r)){const i=(o=r._zod)==null?void 0:o.def;if(i){if(i.value!==void 0)return i.value;if(Array.isArray(i.values)&&i.values.length>0)return i.values[0]}}const t=r._def;if(t){if(t.value!==void 0)return t.value;if(Array.isArray(t.values)&&t.values.length>0)return t.values[0]}const s=r.value;if(s!==void 0)return s}const we="2025-11-25",is=[we,"2025-06-18","2025-03-26","2024-11-05","2024-10-07"],B="io.modelcontextprotocol/related-task",Se="2.0",A=Gt(r=>r!==null&&(typeof r=="object"||typeof r=="function")),gt=v([a(),S().int()]),wt=a();$({ttl:v([S(),ft()]).optional(),pollInterval:S().optional()});const cs=d({ttl:S().optional()}),ls=d({taskId:a()}),je=$({progressToken:gt.optional(),[B]:ls.optional()}),j=d({_meta:je.optional()}),se=j.extend({task:cs.optional()}),us=r=>se.safeParse(r).success,H=d({method:a(),params:j.loose().optional()}),z=d({_meta:je.optional()}),D=d({method:a(),params:z.loose().optional()}),O=$({_meta:je.optional()}),ke=v([a(),S().int()]),St=d({jsonrpc:p(Se),id:ke,...H.shape}).strict(),at=r=>St.safeParse(r).success,kt=d({jsonrpc:p(Se),...D.shape}).strict(),ds=r=>kt.safeParse(r).success,Ve=d({jsonrpc:p(Se),id:ke,result:O}).strict(),le=r=>Ve.safeParse(r).success;var w;(function(r){r[r.ConnectionClosed=-32e3]="ConnectionClosed",r[r.RequestTimeout=-32001]="RequestTimeout",r[r.ParseError=-32700]="ParseError",r[r.InvalidRequest=-32600]="InvalidRequest",r[r.MethodNotFound=-32601]="MethodNotFound",r[r.InvalidParams=-32602]="InvalidParams",r[r.InternalError=-32603]="InternalError",r[r.UrlElicitationRequired=-32042]="UrlElicitationRequired"})(w||(w={}));const ze=d({jsonrpc:p(Se),id:ke.optional(),error:d({code:S().int(),message:a(),data:I().optional()})}).strict(),hs=r=>ze.safeParse(r).success,ps=v([St,kt,Ve,ze]);v([Ve,ze]);const G=O.strict(),ms=z.extend({requestId:ke.optional(),reason:a().optional()}),De=D.extend({method:p("notifications/cancelled"),params:ms}),fs=d({src:a(),mimeType:a().optional(),sizes:u(a()).optional(),theme:V(["light","dark"]).optional()}),re=d({icons:u(fs).optional()}),K=d({name:a(),title:a().optional()}),yt=K.extend({...K.shape,...re.shape,version:a(),websiteUrl:a().optional(),description:a().optional()}),_s=ht(d({applyDefaults:T().optional()}),b(a(),I())),gs=pt(r=>r&&typeof r=="object"&&!Array.isArray(r)&&Object.keys(r).length===0?{form:{}}:r,ht(d({form:_s.optional(),url:A.optional()}),b(a(),I()).optional())),ws=$({list:A.optional(),cancel:A.optional(),requests:$({sampling:$({createMessage:A.optional()}).optional(),elicitation:$({create:A.optional()}).optional()}).optional()}),Ss=$({list:A.optional(),cancel:A.optional(),requests:$({tools:$({call:A.optional()}).optional()}).optional()}),ks=d({experimental:b(a(),A).optional(),sampling:d({context:A.optional(),tools:A.optional()}).optional(),elicitation:gs.optional(),roots:d({listChanged:T().optional()}).optional(),tasks:ws.optional()}),ys=j.extend({protocolVersion:a(),capabilities:ks,clientInfo:yt}),Ts=H.extend({method:p("initialize"),params:ys}),Rs=d({experimental:b(a(),A).optional(),logging:A.optional(),completions:A.optional(),prompts:d({listChanged:T().optional()}).optional(),resources:d({subscribe:T().optional(),listChanged:T().optional()}).optional(),tools:d({listChanged:T().optional()}).optional(),tasks:Ss.optional()}),Tt=O.extend({protocolVersion:a(),capabilities:Rs,serverInfo:yt,instructions:a().optional()}),vs=D.extend({method:p("notifications/initialized"),params:z.optional()}),Fe=H.extend({method:p("ping"),params:j.optional()}),Cs=d({progress:S(),total:E(S()),message:E(a())}),bs=d({...z.shape,...Cs.shape,progressToken:gt}),We=D.extend({method:p("notifications/progress"),params:bs}),qs=j.extend({cursor:wt.optional()}),oe=H.extend({params:qs.optional()}),ae=O.extend({nextCursor:wt.optional()}),Is=V(["working","input_required","completed","failed","cancelled"]),ne=d({taskId:a(),status:Is,ttl:v([S(),ft()]),createdAt:a(),lastUpdatedAt:a(),pollInterval:E(S()),statusMessage:E(a())}),te=O.extend({task:ne}),Es=z.merge(ne),de=D.extend({method:p("notifications/tasks/status"),params:Es}),Je=H.extend({method:p("tasks/get"),params:j.extend({taskId:a()})}),Qe=O.merge(ne),Be=H.extend({method:p("tasks/result"),params:j.extend({taskId:a()})});O.loose();const Ze=oe.extend({method:p("tasks/list")}),Ge=ae.extend({tasks:u(ne)}),Ke=H.extend({method:p("tasks/cancel"),params:j.extend({taskId:a()})}),Ps=O.merge(ne),Rt=d({uri:a(),mimeType:E(a()),_meta:b(a(),I()).optional()}),vt=Rt.extend({text:a()}),Ye=a().refine(r=>{try{return atob(r),!0}catch{return!1}},{message:"Invalid Base64 string"}),Ct=Rt.extend({blob:Ye}),ie=V(["user","assistant"]),X=d({audience:u(ie).optional(),priority:S().min(0).max(1).optional(),lastModified:Zt({offset:!0}).optional()}),bt=d({...K.shape,...re.shape,uri:a(),description:E(a()),mimeType:E(a()),annotations:X.optional(),_meta:E($({}))}),Us=d({...K.shape,...re.shape,uriTemplate:a(),description:E(a()),mimeType:E(a()),annotations:X.optional(),_meta:E($({}))}),xs=oe.extend({method:p("resources/list")}),qt=ae.extend({resources:u(bt)}),Ms=oe.extend({method:p("resources/templates/list")}),It=ae.extend({resourceTemplates:u(Us)}),Xe=j.extend({uri:a()}),$s=Xe,As=H.extend({method:p("resources/read"),params:$s}),Et=O.extend({contents:u(v([vt,Ct]))}),Pt=D.extend({method:p("notifications/resources/list_changed"),params:z.optional()}),Hs=Xe,Os=H.extend({method:p("resources/subscribe"),params:Hs}),Ls=Xe,Ns=H.extend({method:p("resources/unsubscribe"),params:Ls}),js=z.extend({uri:a()}),Vs=D.extend({method:p("notifications/resources/updated"),params:js}),zs=d({name:a(),description:E(a()),required:E(T())}),Ds=d({...K.shape,...re.shape,description:E(a()),arguments:E(u(zs)),_meta:E($({}))}),Fs=oe.extend({method:p("prompts/list")}),Ut=ae.extend({prompts:u(Ds)}),Ws=j.extend({name:a(),arguments:b(a(),a()).optional()}),Js=H.extend({method:p("prompts/get"),params:Ws}),et=d({type:p("text"),text:a(),annotations:X.optional(),_meta:b(a(),I()).optional()}),tt=d({type:p("image"),data:Ye,mimeType:a(),annotations:X.optional(),_meta:b(a(),I()).optional()}),st=d({type:p("audio"),data:Ye,mimeType:a(),annotations:X.optional(),_meta:b(a(),I()).optional()}),Qs=d({type:p("tool_use"),name:a(),id:a(),input:b(a(),I()),_meta:b(a(),I()).optional()}),Bs=d({type:p("resource"),resource:v([vt,Ct]),annotations:X.optional(),_meta:b(a(),I()).optional()}),Zs=bt.extend({type:p("resource_link")}),rt=v([et,tt,st,Zs,Bs]),Gs=d({role:ie,content:rt}),xt=O.extend({description:a().optional(),messages:u(Gs)}),Mt=D.extend({method:p("notifications/prompts/list_changed"),params:z.optional()}),Ks=d({title:a().optional(),readOnlyHint:T().optional(),destructiveHint:T().optional(),idempotentHint:T().optional(),openWorldHint:T().optional()}),Ys=d({taskSupport:V(["required","optional","forbidden"]).optional()}),$t=d({...K.shape,...re.shape,description:a().optional(),inputSchema:d({type:p("object"),properties:b(a(),A).optional(),required:u(a()).optional()}).catchall(I()),outputSchema:d({type:p("object"),properties:b(a(),A).optional(),required:u(a()).optional()}).catchall(I()).optional(),annotations:Ks.optional(),execution:Ys.optional(),_meta:b(a(),I()).optional()}),Xs=oe.extend({method:p("tools/list")}),At=ae.extend({tools:u($t)}),ye=O.extend({content:u(rt).default([]),structuredContent:b(a(),I()).optional(),isError:T().optional()});ye.or(O.extend({toolResult:I()}));const er=se.extend({name:a(),arguments:b(a(),I()).optional()}),tr=H.extend({method:p("tools/call"),params:er}),Ht=D.extend({method:p("notifications/tools/list_changed"),params:z.optional()}),sr=d({autoRefresh:T().default(!0),debounceMs:S().int().nonnegative().default(300)}),Ot=V(["debug","info","notice","warning","error","critical","alert","emergency"]),rr=j.extend({level:Ot}),or=H.extend({method:p("logging/setLevel"),params:rr}),ar=z.extend({level:Ot,logger:a().optional(),data:I()}),nr=D.extend({method:p("notifications/message"),params:ar}),ir=d({name:a().optional()}),cr=d({hints:u(ir).optional(),costPriority:S().min(0).max(1).optional(),speedPriority:S().min(0).max(1).optional(),intelligencePriority:S().min(0).max(1).optional()}),lr=d({mode:V(["auto","required","none"]).optional()}),ur=d({type:p("tool_result"),toolUseId:a().describe("The unique identifier for the corresponding tool call."),content:u(rt).default([]),structuredContent:d({}).loose().optional(),isError:T().optional(),_meta:b(a(),I()).optional()}),dr=mt("type",[et,tt,st]),he=mt("type",[et,tt,st,Qs,ur]),hr=d({role:ie,content:v([he,u(he)]),_meta:b(a(),I()).optional()}),pr=se.extend({messages:u(hr),modelPreferences:cr.optional(),systemPrompt:a().optional(),includeContext:V(["none","thisServer","allServers"]).optional(),temperature:S().optional(),maxTokens:S().int(),stopSequences:u(a()).optional(),metadata:A.optional(),tools:u($t).optional(),toolChoice:lr.optional()}),Lt=H.extend({method:p("sampling/createMessage"),params:pr}),Nt=O.extend({model:a(),stopReason:E(V(["endTurn","stopSequence","maxTokens"]).or(a())),role:ie,content:dr}),jt=O.extend({model:a(),stopReason:E(V(["endTurn","stopSequence","maxTokens","toolUse"]).or(a())),role:ie,content:v([he,u(he)])}),mr=d({type:p("boolean"),title:a().optional(),description:a().optional(),default:T().optional()}),fr=d({type:p("string"),title:a().optional(),description:a().optional(),minLength:S().optional(),maxLength:S().optional(),format:V(["email","uri","date","date-time"]).optional(),default:a().optional()}),_r=d({type:V(["number","integer"]),title:a().optional(),description:a().optional(),minimum:S().optional(),maximum:S().optional(),default:S().optional()}),gr=d({type:p("string"),title:a().optional(),description:a().optional(),enum:u(a()),default:a().optional()}),wr=d({type:p("string"),title:a().optional(),description:a().optional(),oneOf:u(d({const:a(),title:a()})),default:a().optional()}),Sr=d({type:p("string"),title:a().optional(),description:a().optional(),enum:u(a()),enumNames:u(a()).optional(),default:a().optional()}),kr=v([gr,wr]),yr=d({type:p("array"),title:a().optional(),description:a().optional(),minItems:S().optional(),maxItems:S().optional(),items:d({type:p("string"),enum:u(a())}),default:u(a()).optional()}),Tr=d({type:p("array"),title:a().optional(),description:a().optional(),minItems:S().optional(),maxItems:S().optional(),items:d({anyOf:u(d({const:a(),title:a()}))}),default:u(a()).optional()}),Rr=v([yr,Tr]),vr=v([Sr,kr,Rr]),Cr=v([vr,mr,fr,_r]),br=se.extend({mode:p("form").optional(),message:a(),requestedSchema:d({type:p("object"),properties:b(a(),Cr),required:u(a()).optional()})}),qr=se.extend({mode:p("url"),message:a(),elicitationId:a(),url:a().url()}),Ir=v([br,qr]),Vt=H.extend({method:p("elicitation/create"),params:Ir}),Er=z.extend({elicitationId:a()}),Pr=D.extend({method:p("notifications/elicitation/complete"),params:Er}),zt=O.extend({action:V(["accept","decline","cancel"]),content:pt(r=>r===null?void 0:r,b(a(),v([a(),S(),T(),u(a())])).optional())}),Ur=d({type:p("ref/resource"),uri:a()}),xr=d({type:p("ref/prompt"),name:a()}),Mr=j.extend({ref:v([xr,Ur]),argument:d({name:a(),value:a()}),context:d({arguments:b(a(),a()).optional()}).optional()}),$r=H.extend({method:p("completion/complete"),params:Mr}),Dt=O.extend({completion:$({values:u(a()).max(100),total:E(S().int()),hasMore:E(T())})}),Ar=d({uri:a().startsWith("file://"),name:a().optional(),_meta:b(a(),I()).optional()}),Hr=H.extend({method:p("roots/list"),params:j.optional()}),Or=O.extend({roots:u(Ar)}),Lr=D.extend({method:p("notifications/roots/list_changed"),params:z.optional()});v([Fe,Ts,$r,or,Js,Fs,xs,Ms,As,Os,Ns,tr,Xs,Je,Be,Ze,Ke]);v([De,We,vs,Lr,de]);v([G,Nt,jt,zt,Or,Qe,Ge,te]);v([Fe,Lt,Vt,Hr,Je,Be,Ze,Ke]);v([De,We,nr,Vs,Pt,Ht,Mt,de,Pr]);v([G,Tt,Dt,xt,Ut,qt,It,Et,ye,At,Qe,Ge,te]);class f extends Error{constructor(e,t,s){super(`MCP error ${e}: ${t}`),this.code=e,this.data=s,this.name="McpError"}static fromError(e,t,s){if(e===w.UrlElicitationRequired&&s){const o=s;if(o.elicitations)return new Nr(o.elicitations,t)}return new f(e,t,s)}}class Nr extends f{constructor(e,t=`URL elicitation${e.length>1?"s":""} required`){super(w.UrlElicitationRequired,t,{elicitations:e})}get elicitations(){var e;return((e=this.data)==null?void 0:e.elicitations)??[]}}function Q(r){return r==="completed"||r==="failed"||r==="cancelled"}function nt(r){const e=_t(r),t=e==null?void 0:e.method;if(!t)throw new Error("Schema is missing a method literal");const s=ns(t);if(typeof s!="string")throw new Error("Schema method literal must be a string");return s}function it(r,e){const t=J(r,e);if(!t.success)throw t.error;return t.data}const jr=6e4;class Vr{constructor(e){this._options=e,this._requestMessageId=0,this._requestHandlers=new Map,this._requestHandlerAbortControllers=new Map,this._notificationHandlers=new Map,this._responseHandlers=new Map,this._progressHandlers=new Map,this._timeoutInfo=new Map,this._pendingDebouncedNotifications=new Set,this._taskProgressTokens=new Map,this._requestResolvers=new Map,this.setNotificationHandler(De,t=>{this._oncancel(t)}),this.setNotificationHandler(We,t=>{this._onprogress(t)}),this.setRequestHandler(Fe,t=>({})),this._taskStore=e==null?void 0:e.taskStore,this._taskMessageQueue=e==null?void 0:e.taskMessageQueue,this._taskStore&&(this.setRequestHandler(Je,async(t,s)=>{const o=await this._taskStore.getTask(t.params.taskId,s.sessionId);if(!o)throw new f(w.InvalidParams,"Failed to retrieve task: Task not found");return{...o}}),this.setRequestHandler(Be,async(t,s)=>{const o=async()=>{var l;const n=t.params.taskId;if(this._taskMessageQueue){let c;for(;c=await this._taskMessageQueue.dequeue(n,s.sessionId);){if(c.type==="response"||c.type==="error"){const h=c.message,m=h.id,g=this._requestResolvers.get(m);if(g)if(this._requestResolvers.delete(m),c.type==="response")g(h);else{const _=h,C=new f(_.error.code,_.error.message,_.error.data);g(C)}else{const _=c.type==="response"?"Response":"Error";this._onerror(new Error(`${_} handler missing for request ${m}`))}continue}await((l=this._transport)==null?void 0:l.send(c.message,{relatedRequestId:s.requestId}))}}const i=await this._taskStore.getTask(n,s.sessionId);if(!i)throw new f(w.InvalidParams,`Task not found: ${n}`);if(!Q(i.status))return await this._waitForTaskUpdate(n,s.signal),await o();if(Q(i.status)){const c=await this._taskStore.getTaskResult(n,s.sessionId);return this._clearTaskQueue(n),{...c,_meta:{...c._meta,[B]:{taskId:n}}}}return await o()};return await o()}),this.setRequestHandler(Ze,async(t,s)=>{var o;try{const{tasks:n,nextCursor:i}=await this._taskStore.listTasks((o=t.params)==null?void 0:o.cursor,s.sessionId);return{tasks:n,nextCursor:i,_meta:{}}}catch(n){throw new f(w.InvalidParams,`Failed to list tasks: ${n instanceof Error?n.message:String(n)}`)}}),this.setRequestHandler(Ke,async(t,s)=>{try{const o=await this._taskStore.getTask(t.params.taskId,s.sessionId);if(!o)throw new f(w.InvalidParams,`Task not found: ${t.params.taskId}`);if(Q(o.status))throw new f(w.InvalidParams,`Cannot cancel task in terminal status: ${o.status}`);await this._taskStore.updateTaskStatus(t.params.taskId,"cancelled","Client cancelled task execution.",s.sessionId),this._clearTaskQueue(t.params.taskId);const n=await this._taskStore.getTask(t.params.taskId,s.sessionId);if(!n)throw new f(w.InvalidParams,`Task not found after cancellation: ${t.params.taskId}`);return{_meta:{},...n}}catch(o){throw o instanceof f?o:new f(w.InvalidRequest,`Failed to cancel task: ${o instanceof Error?o.message:String(o)}`)}}))}async _oncancel(e){if(!e.params.requestId)return;const t=this._requestHandlerAbortControllers.get(e.params.requestId);t==null||t.abort(e.params.reason)}_setupTimeout(e,t,s,o,n=!1){this._timeoutInfo.set(e,{timeoutId:setTimeout(o,t),startTime:Date.now(),timeout:t,maxTotalTimeout:s,resetTimeoutOnProgress:n,onTimeout:o})}_resetTimeout(e){const t=this._timeoutInfo.get(e);if(!t)return!1;const s=Date.now()-t.startTime;if(t.maxTotalTimeout&&s>=t.maxTotalTimeout)throw this._timeoutInfo.delete(e),f.fromError(w.RequestTimeout,"Maximum total timeout exceeded",{maxTotalTimeout:t.maxTotalTimeout,totalElapsed:s});return clearTimeout(t.timeoutId),t.timeoutId=setTimeout(t.onTimeout,t.timeout),!0}_cleanupTimeout(e){const t=this._timeoutInfo.get(e);t&&(clearTimeout(t.timeoutId),this._timeoutInfo.delete(e))}async connect(e){var n,i,l;this._transport=e;const t=(n=this.transport)==null?void 0:n.onclose;this._transport.onclose=()=>{t==null||t(),this._onclose()};const s=(i=this.transport)==null?void 0:i.onerror;this._transport.onerror=c=>{s==null||s(c),this._onerror(c)};const o=(l=this._transport)==null?void 0:l.onmessage;this._transport.onmessage=(c,h)=>{o==null||o(c,h),le(c)||hs(c)?this._onresponse(c):at(c)?this._onrequest(c,h):ds(c)?this._onnotification(c):this._onerror(new Error(`Unknown message type: ${JSON.stringify(c)}`))},await this._transport.start()}_onclose(){var s;const e=this._responseHandlers;this._responseHandlers=new Map,this._progressHandlers.clear(),this._taskProgressTokens.clear(),this._pendingDebouncedNotifications.clear();const t=f.fromError(w.ConnectionClosed,"Connection closed");this._transport=void 0,(s=this.onclose)==null||s.call(this);for(const o of e.values())o(t)}_onerror(e){var t;(t=this.onerror)==null||t.call(this,e)}_onnotification(e){const t=this._notificationHandlers.get(e.method)??this.fallbackNotificationHandler;t!==void 0&&Promise.resolve().then(()=>t(e)).catch(s=>this._onerror(new Error(`Uncaught error in notification handler: ${s}`)))}_onrequest(e,t){var m,g,_,C;const s=this._requestHandlers.get(e.method)??this.fallbackRequestHandler,o=this._transport,n=(_=(g=(m=e.params)==null?void 0:m._meta)==null?void 0:g[B])==null?void 0:_.taskId;if(s===void 0){const k={jsonrpc:"2.0",id:e.id,error:{code:w.MethodNotFound,message:"Method not found"}};n&&this._taskMessageQueue?this._enqueueTaskMessage(n,{type:"error",message:k,timestamp:Date.now()},o==null?void 0:o.sessionId).catch(R=>this._onerror(new Error(`Failed to enqueue error response: ${R}`))):o==null||o.send(k).catch(R=>this._onerror(new Error(`Failed to send an error response: ${R}`)));return}const i=new AbortController;this._requestHandlerAbortControllers.set(e.id,i);const l=us(e.params)?e.params.task:void 0,c=this._taskStore?this.requestTaskStore(e,o==null?void 0:o.sessionId):void 0,h={signal:i.signal,sessionId:o==null?void 0:o.sessionId,_meta:(C=e.params)==null?void 0:C._meta,sendNotification:async k=>{const R={relatedRequestId:e.id};n&&(R.relatedTask={taskId:n}),await this.notification(k,R)},sendRequest:async(k,R,U)=>{var N;const y={...U,relatedRequestId:e.id};n&&!y.relatedTask&&(y.relatedTask={taskId:n});const q=((N=y.relatedTask)==null?void 0:N.taskId)??n;return q&&c&&await c.updateTaskStatus(q,"input_required"),await this.request(k,R,y)},authInfo:t==null?void 0:t.authInfo,requestId:e.id,requestInfo:t==null?void 0:t.requestInfo,taskId:n,taskStore:c,taskRequestedTtl:l==null?void 0:l.ttl,closeSSEStream:t==null?void 0:t.closeSSEStream,closeStandaloneSSEStream:t==null?void 0:t.closeStandaloneSSEStream};Promise.resolve().then(()=>{l&&this.assertTaskHandlerCapability(e.method)}).then(()=>s(e,h)).then(async k=>{if(i.signal.aborted)return;const R={result:k,jsonrpc:"2.0",id:e.id};n&&this._taskMessageQueue?await this._enqueueTaskMessage(n,{type:"response",message:R,timestamp:Date.now()},o==null?void 0:o.sessionId):await(o==null?void 0:o.send(R))},async k=>{if(i.signal.aborted)return;const R={jsonrpc:"2.0",id:e.id,error:{code:Number.isSafeInteger(k.code)?k.code:w.InternalError,message:k.message??"Internal error",...k.data!==void 0&&{data:k.data}}};n&&this._taskMessageQueue?await this._enqueueTaskMessage(n,{type:"error",message:R,timestamp:Date.now()},o==null?void 0:o.sessionId):await(o==null?void 0:o.send(R))}).catch(k=>this._onerror(new Error(`Failed to send response: ${k}`))).finally(()=>{this._requestHandlerAbortControllers.delete(e.id)})}_onprogress(e){const{progressToken:t,...s}=e.params,o=Number(t),n=this._progressHandlers.get(o);if(!n){this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(e)}`));return}const i=this._responseHandlers.get(o),l=this._timeoutInfo.get(o);if(l&&i&&l.resetTimeoutOnProgress)try{this._resetTimeout(o)}catch(c){this._responseHandlers.delete(o),this._progressHandlers.delete(o),this._cleanupTimeout(o),i(c);return}n(s)}_onresponse(e){const t=Number(e.id),s=this._requestResolvers.get(t);if(s){if(this._requestResolvers.delete(t),le(e))s(e);else{const i=new f(e.error.code,e.error.message,e.error.data);s(i)}return}const o=this._responseHandlers.get(t);if(o===void 0){this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(e)}`));return}this._responseHandlers.delete(t),this._cleanupTimeout(t);let n=!1;if(le(e)&&e.result&&typeof e.result=="object"){const i=e.result;if(i.task&&typeof i.task=="object"){const l=i.task;typeof l.taskId=="string"&&(n=!0,this._taskProgressTokens.set(l.taskId,t))}}if(n||this._progressHandlers.delete(t),le(e))o(e);else{const i=f.fromError(e.error.code,e.error.message,e.error.data);o(i)}}get transport(){return this._transport}async close(){var e;await((e=this._transport)==null?void 0:e.close())}async*requestStream(e,t,s){var i,l;const{task:o}=s??{};if(!o){try{yield{type:"result",result:await this.request(e,t,s)}}catch(c){yield{type:"error",error:c instanceof f?c:new f(w.InternalError,String(c))}}return}let n;try{const c=await this.request(e,te,s);if(c.task)n=c.task.taskId,yield{type:"taskCreated",task:c.task};else throw new f(w.InternalError,"Task creation did not return a task");for(;;){const h=await this.getTask({taskId:n},s);if(yield{type:"taskStatus",task:h},Q(h.status)){h.status==="completed"?yield{type:"result",result:await this.getTaskResult({taskId:n},t,s)}:h.status==="failed"?yield{type:"error",error:new f(w.InternalError,`Task ${n} failed`)}:h.status==="cancelled"&&(yield{type:"error",error:new f(w.InternalError,`Task ${n} was cancelled`)});return}if(h.status==="input_required"){yield{type:"result",result:await this.getTaskResult({taskId:n},t,s)};return}const m=h.pollInterval??((i=this._options)==null?void 0:i.defaultTaskPollInterval)??1e3;await new Promise(g=>setTimeout(g,m)),(l=s==null?void 0:s.signal)==null||l.throwIfAborted()}}catch(c){yield{type:"error",error:c instanceof f?c:new f(w.InternalError,String(c))}}}request(e,t,s){const{relatedRequestId:o,resumptionToken:n,onresumptiontoken:i,task:l,relatedTask:c}=s??{};return new Promise((h,m)=>{var q,N,Z,L,ce;const g=P=>{m(P)};if(!this._transport){g(new Error("Not connected"));return}if(((q=this._options)==null?void 0:q.enforceStrictCapabilities)===!0)try{this.assertCapabilityForMethod(e.method),l&&this.assertTaskCapability(e.method)}catch(P){g(P);return}(N=s==null?void 0:s.signal)==null||N.throwIfAborted();const _=this._requestMessageId++,C={...e,jsonrpc:"2.0",id:_};s!=null&&s.onprogress&&(this._progressHandlers.set(_,s.onprogress),C.params={...e.params,_meta:{...((Z=e.params)==null?void 0:Z._meta)||{},progressToken:_}}),l&&(C.params={...C.params,task:l}),c&&(C.params={...C.params,_meta:{...((L=C.params)==null?void 0:L._meta)||{},[B]:c}});const k=P=>{var F;this._responseHandlers.delete(_),this._progressHandlers.delete(_),this._cleanupTimeout(_),(F=this._transport)==null||F.send({jsonrpc:"2.0",method:"notifications/cancelled",params:{requestId:_,reason:String(P)}},{relatedRequestId:o,resumptionToken:n,onresumptiontoken:i}).catch(Qt=>this._onerror(new Error(`Failed to send cancellation: ${Qt}`)));const W=P instanceof f?P:new f(w.RequestTimeout,String(P));m(W)};this._responseHandlers.set(_,P=>{var W;if(!((W=s==null?void 0:s.signal)!=null&&W.aborted)){if(P instanceof Error)return m(P);try{const F=J(t,P.result);F.success?h(F.data):m(F.error)}catch(F){m(F)}}}),(ce=s==null?void 0:s.signal)==null||ce.addEventListener("abort",()=>{var P;k((P=s==null?void 0:s.signal)==null?void 0:P.reason)});const R=(s==null?void 0:s.timeout)??jr,U=()=>k(f.fromError(w.RequestTimeout,"Request timed out",{timeout:R}));this._setupTimeout(_,R,s==null?void 0:s.maxTotalTimeout,U,(s==null?void 0:s.resetTimeoutOnProgress)??!1);const y=c==null?void 0:c.taskId;if(y){const P=W=>{const F=this._responseHandlers.get(_);F?F(W):this._onerror(new Error(`Response handler missing for side-channeled request ${_}`))};this._requestResolvers.set(_,P),this._enqueueTaskMessage(y,{type:"request",message:C,timestamp:Date.now()}).catch(W=>{this._cleanupTimeout(_),m(W)})}else this._transport.send(C,{relatedRequestId:o,resumptionToken:n,onresumptiontoken:i}).catch(P=>{this._cleanupTimeout(_),m(P)})})}async getTask(e,t){return this.request({method:"tasks/get",params:e},Qe,t)}async getTaskResult(e,t,s){return this.request({method:"tasks/result",params:e},t,s)}async listTasks(e,t){return this.request({method:"tasks/list",params:e},Ge,t)}async cancelTask(e,t){return this.request({method:"tasks/cancel",params:e},Ps,t)}async notification(e,t){var l,c,h,m;if(!this._transport)throw new Error("Not connected");this.assertNotificationCapability(e.method);const s=(l=t==null?void 0:t.relatedTask)==null?void 0:l.taskId;if(s){const g={...e,jsonrpc:"2.0",params:{...e.params,_meta:{...((c=e.params)==null?void 0:c._meta)||{},[B]:t.relatedTask}}};await this._enqueueTaskMessage(s,{type:"notification",message:g,timestamp:Date.now()});return}if((((h=this._options)==null?void 0:h.debouncedNotificationMethods)??[]).includes(e.method)&&!e.params&&!(t!=null&&t.relatedRequestId)&&!(t!=null&&t.relatedTask)){if(this._pendingDebouncedNotifications.has(e.method))return;this._pendingDebouncedNotifications.add(e.method),Promise.resolve().then(()=>{var _,C;if(this._pendingDebouncedNotifications.delete(e.method),!this._transport)return;let g={...e,jsonrpc:"2.0"};t!=null&&t.relatedTask&&(g={...g,params:{...g.params,_meta:{...((_=g.params)==null?void 0:_._meta)||{},[B]:t.relatedTask}}}),(C=this._transport)==null||C.send(g,t).catch(k=>this._onerror(k))});return}let i={...e,jsonrpc:"2.0"};t!=null&&t.relatedTask&&(i={...i,params:{...i.params,_meta:{...((m=i.params)==null?void 0:m._meta)||{},[B]:t.relatedTask}}}),await this._transport.send(i,t)}setRequestHandler(e,t){const s=nt(e);this.assertRequestHandlerCapability(s),this._requestHandlers.set(s,(o,n)=>{const i=it(e,o);return Promise.resolve(t(i,n))})}removeRequestHandler(e){this._requestHandlers.delete(e)}assertCanSetRequestHandler(e){if(this._requestHandlers.has(e))throw new Error(`A request handler for ${e} already exists, which would be overridden`)}setNotificationHandler(e,t){const s=nt(e);this._notificationHandlers.set(s,o=>{const n=it(e,o);return Promise.resolve(t(n))})}removeNotificationHandler(e){this._notificationHandlers.delete(e)}_cleanupTaskProgressHandler(e){const t=this._taskProgressTokens.get(e);t!==void 0&&(this._progressHandlers.delete(t),this._taskProgressTokens.delete(e))}async _enqueueTaskMessage(e,t,s){var n;if(!this._taskStore||!this._taskMessageQueue)throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");const o=(n=this._options)==null?void 0:n.maxTaskQueueSize;await this._taskMessageQueue.enqueue(e,t,s,o)}async _clearTaskQueue(e,t){if(this._taskMessageQueue){const s=await this._taskMessageQueue.dequeueAll(e,t);for(const o of s)if(o.type==="request"&&at(o.message)){const n=o.message.id,i=this._requestResolvers.get(n);i?(i(new f(w.InternalError,"Task cancelled or completed")),this._requestResolvers.delete(n)):this._onerror(new Error(`Resolver missing for request ${n} during task ${e} cleanup`))}}}async _waitForTaskUpdate(e,t){var o,n;let s=((o=this._options)==null?void 0:o.defaultTaskPollInterval)??1e3;try{const i=await((n=this._taskStore)==null?void 0:n.getTask(e));i!=null&&i.pollInterval&&(s=i.pollInterval)}catch{}return new Promise((i,l)=>{if(t.aborted){l(new f(w.InvalidRequest,"Request cancelled"));return}const c=setTimeout(i,s);t.addEventListener("abort",()=>{clearTimeout(c),l(new f(w.InvalidRequest,"Request cancelled"))},{once:!0})})}requestTaskStore(e,t){const s=this._taskStore;if(!s)throw new Error("No task store configured");return{createTask:async o=>{if(!e)throw new Error("No request provided");return await s.createTask(o,e.id,{method:e.method,params:e.params},t)},getTask:async o=>{const n=await s.getTask(o,t);if(!n)throw new f(w.InvalidParams,"Failed to retrieve task: Task not found");return n},storeTaskResult:async(o,n,i)=>{await s.storeTaskResult(o,n,i,t);const l=await s.getTask(o,t);if(l){const c=de.parse({method:"notifications/tasks/status",params:l});await this.notification(c),Q(l.status)&&this._cleanupTaskProgressHandler(o)}},getTaskResult:o=>s.getTaskResult(o,t),updateTaskStatus:async(o,n,i)=>{const l=await s.getTask(o,t);if(!l)throw new f(w.InvalidParams,`Task "${o}" not found - it may have been cleaned up`);if(Q(l.status))throw new f(w.InvalidParams,`Cannot update task "${o}" from terminal status "${l.status}" to "${n}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);await s.updateTaskStatus(o,n,i,t);const c=await s.getTask(o,t);if(c){const h=de.parse({method:"notifications/tasks/status",params:c});await this.notification(h),Q(c.status)&&this._cleanupTaskProgressHandler(o)}},listTasks:o=>s.listTasks(o,t)}}}function ct(r){return r!==null&&typeof r=="object"&&!Array.isArray(r)}function zr(r,e){const t={...r};for(const s in e){const o=s,n=e[o];if(n===void 0)continue;const i=t[o];ct(i)&&ct(n)?t[o]={...i,...n}:t[o]=n}return t}function Dr(){const r=new Kt({strict:!1,validateFormats:!0,validateSchema:!1,allErrors:!0});return Yt(r),r}class Fr{constructor(e){this._ajv=e??Dr()}getValidator(e){const t="$id"in e&&typeof e.$id=="string"?this._ajv.getSchema(e.$id)??this._ajv.compile(e):this._ajv.compile(e);return s=>t(s)?{valid:!0,data:s,errorMessage:void 0}:{valid:!1,data:void 0,errorMessage:this._ajv.errorsText(t.errors)}}}class Wr{constructor(e){this._client=e}async*callToolStream(e,t=ye,s){const o=this._client,n={...s,task:(s==null?void 0:s.task)??(o.isToolTask(e.name)?{}:void 0)},i=o.requestStream({method:"tools/call",params:e},t,n),l=o.getToolOutputValidator(e.name);for await(const c of i){if(c.type==="result"&&l){const h=c.result;if(!h.structuredContent&&!h.isError){yield{type:"error",error:new f(w.InvalidRequest,`Tool ${e.name} has an output schema but did not return structured content`)};return}if(h.structuredContent)try{const m=l(h.structuredContent);if(!m.valid){yield{type:"error",error:new f(w.InvalidParams,`Structured content does not match the tool's output schema: ${m.errorMessage}`)};return}}catch(m){if(m instanceof f){yield{type:"error",error:m};return}yield{type:"error",error:new f(w.InvalidParams,`Failed to validate structured content: ${m instanceof Error?m.message:String(m)}`)};return}}yield c}}async getTask(e,t){return this._client.getTask({taskId:e},t)}async getTaskResult(e,t,s){return this._client.getTaskResult({taskId:e},t,s)}async listTasks(e,t){return this._client.listTasks(e?{cursor:e}:void 0,t)}async cancelTask(e,t){return this._client.cancelTask({taskId:e},t)}requestStream(e,t,s){return this._client.requestStream(e,t,s)}}function Jr(r,e,t){var s;if(!r)throw new Error(`${t} does not support task creation (required for ${e})`);switch(e){case"tools/call":if(!((s=r.tools)!=null&&s.call))throw new Error(`${t} does not support task creation for tools/call (required for ${e})`);break}}function Qr(r,e,t){var s,o;if(!r)throw new Error(`${t} does not support task creation (required for ${e})`);switch(e){case"sampling/createMessage":if(!((s=r.sampling)!=null&&s.createMessage))throw new Error(`${t} does not support task creation for sampling/createMessage (required for ${e})`);break;case"elicitation/create":if(!((o=r.elicitation)!=null&&o.create))throw new Error(`${t} does not support task creation for elicitation/create (required for ${e})`);break}}function ue(r,e){if(!(!r||e===null||typeof e!="object")){if(r.type==="object"&&r.properties&&typeof r.properties=="object"){const t=e,s=r.properties;for(const o of Object.keys(s)){const n=s[o];t[o]===void 0&&Object.prototype.hasOwnProperty.call(n,"default")&&(t[o]=n.default),t[o]!==void 0&&ue(n,t[o])}}if(Array.isArray(r.anyOf))for(const t of r.anyOf)typeof t!="boolean"&&ue(t,e);if(Array.isArray(r.oneOf))for(const t of r.oneOf)typeof t!="boolean"&&ue(t,e)}}function Br(r){if(!r)return{supportsFormMode:!1,supportsUrlMode:!1};const e=r.form!==void 0,t=r.url!==void 0;return{supportsFormMode:e||!e&&!t,supportsUrlMode:t}}class Eo extends Vr{constructor(e,t){super(t),this._clientInfo=e,this._cachedToolOutputValidators=new Map,this._cachedKnownTaskTools=new Set,this._cachedRequiredTaskTools=new Set,this._listChangedDebounceTimers=new Map,this._capabilities=(t==null?void 0:t.capabilities)??{},this._jsonSchemaValidator=(t==null?void 0:t.jsonSchemaValidator)??new Fr,t!=null&&t.listChanged&&(this._pendingListChangedConfig=t.listChanged)}_setupListChangedHandlers(e){var t,s,o,n,i,l;e.tools&&((s=(t=this._serverCapabilities)==null?void 0:t.tools)!=null&&s.listChanged)&&this._setupListChangedHandler("tools",Ht,e.tools,async()=>(await this.listTools()).tools),e.prompts&&((n=(o=this._serverCapabilities)==null?void 0:o.prompts)!=null&&n.listChanged)&&this._setupListChangedHandler("prompts",Mt,e.prompts,async()=>(await this.listPrompts()).prompts),e.resources&&((l=(i=this._serverCapabilities)==null?void 0:i.resources)!=null&&l.listChanged)&&this._setupListChangedHandler("resources",Pt,e.resources,async()=>(await this.listResources()).resources)}get experimental(){return this._experimental||(this._experimental={tasks:new Wr(this)}),this._experimental}registerCapabilities(e){if(this.transport)throw new Error("Cannot register capabilities after connecting to transport");this._capabilities=zr(this._capabilities,e)}setRequestHandler(e,t){var l;const s=_t(e),o=s==null?void 0:s.method;if(!o)throw new Error("Schema is missing a method literal");let n;if(ge(o)){const c=o,h=(l=c._zod)==null?void 0:l.def;n=(h==null?void 0:h.value)??c.value}else{const c=o,h=c._def;n=(h==null?void 0:h.value)??c.value}if(typeof n!="string")throw new Error("Schema method literal must be a string");const i=n;if(i==="elicitation/create"){const c=async(h,m)=>{var N,Z;const g=J(Vt,h);if(!g.success){const L=g.error instanceof Error?g.error.message:String(g.error);throw new f(w.InvalidParams,`Invalid elicitation request: ${L}`)}const{params:_}=g.data;_.mode=_.mode??"form";const{supportsFormMode:C,supportsUrlMode:k}=Br(this._capabilities.elicitation);if(_.mode==="form"&&!C)throw new f(w.InvalidParams,"Client does not support form-mode elicitation requests");if(_.mode==="url"&&!k)throw new f(w.InvalidParams,"Client does not support URL-mode elicitation requests");const R=await Promise.resolve(t(h,m));if(_.task){const L=J(te,R);if(!L.success){const ce=L.error instanceof Error?L.error.message:String(L.error);throw new f(w.InvalidParams,`Invalid task creation result: ${ce}`)}return L.data}const U=J(zt,R);if(!U.success){const L=U.error instanceof Error?U.error.message:String(U.error);throw new f(w.InvalidParams,`Invalid elicitation result: ${L}`)}const y=U.data,q=_.mode==="form"?_.requestedSchema:void 0;if(_.mode==="form"&&y.action==="accept"&&y.content&&q&&(Z=(N=this._capabilities.elicitation)==null?void 0:N.form)!=null&&Z.applyDefaults)try{ue(q,y.content)}catch{}return y};return super.setRequestHandler(e,c)}if(i==="sampling/createMessage"){const c=async(h,m)=>{const g=J(Lt,h);if(!g.success){const y=g.error instanceof Error?g.error.message:String(g.error);throw new f(w.InvalidParams,`Invalid sampling request: ${y}`)}const{params:_}=g.data,C=await Promise.resolve(t(h,m));if(_.task){const y=J(te,C);if(!y.success){const q=y.error instanceof Error?y.error.message:String(y.error);throw new f(w.InvalidParams,`Invalid task creation result: ${q}`)}return y.data}const R=_.tools||_.toolChoice?jt:Nt,U=J(R,C);if(!U.success){const y=U.error instanceof Error?U.error.message:String(U.error);throw new f(w.InvalidParams,`Invalid sampling result: ${y}`)}return U.data};return super.setRequestHandler(e,c)}return super.setRequestHandler(e,t)}assertCapability(e,t){var s;if(!((s=this._serverCapabilities)!=null&&s[e]))throw new Error(`Server does not support ${e} (required for ${t})`)}async connect(e,t){if(await super.connect(e),e.sessionId===void 0)try{const s=await this.request({method:"initialize",params:{protocolVersion:we,capabilities:this._capabilities,clientInfo:this._clientInfo}},Tt,t);if(s===void 0)throw new Error(`Server sent invalid initialize result: ${s}`);if(!is.includes(s.protocolVersion))throw new Error(`Server's protocol version is not supported: ${s.protocolVersion}`);this._serverCapabilities=s.capabilities,this._serverVersion=s.serverInfo,e.setProtocolVersion&&e.setProtocolVersion(s.protocolVersion),this._instructions=s.instructions,await this.notification({method:"notifications/initialized"}),this._pendingListChangedConfig&&(this._setupListChangedHandlers(this._pendingListChangedConfig),this._pendingListChangedConfig=void 0)}catch(s){throw this.close(),s}}getServerCapabilities(){return this._serverCapabilities}getServerVersion(){return this._serverVersion}getInstructions(){return this._instructions}assertCapabilityForMethod(e){var t,s,o,n,i;switch(e){case"logging/setLevel":if(!((t=this._serverCapabilities)!=null&&t.logging))throw new Error(`Server does not support logging (required for ${e})`);break;case"prompts/get":case"prompts/list":if(!((s=this._serverCapabilities)!=null&&s.prompts))throw new Error(`Server does not support prompts (required for ${e})`);break;case"resources/list":case"resources/templates/list":case"resources/read":case"resources/subscribe":case"resources/unsubscribe":if(!((o=this._serverCapabilities)!=null&&o.resources))throw new Error(`Server does not support resources (required for ${e})`);if(e==="resources/subscribe"&&!this._serverCapabilities.resources.subscribe)throw new Error(`Server does not support resource subscriptions (required for ${e})`);break;case"tools/call":case"tools/list":if(!((n=this._serverCapabilities)!=null&&n.tools))throw new Error(`Server does not support tools (required for ${e})`);break;case"completion/complete":if(!((i=this._serverCapabilities)!=null&&i.completions))throw new Error(`Server does not support completions (required for ${e})`);break}}assertNotificationCapability(e){var t;switch(e){case"notifications/roots/list_changed":if(!((t=this._capabilities.roots)!=null&&t.listChanged))throw new Error(`Client does not support roots list changed notifications (required for ${e})`);break}}assertRequestHandlerCapability(e){if(this._capabilities)switch(e){case"sampling/createMessage":if(!this._capabilities.sampling)throw new Error(`Client does not support sampling capability (required for ${e})`);break;case"elicitation/create":if(!this._capabilities.elicitation)throw new Error(`Client does not support elicitation capability (required for ${e})`);break;case"roots/list":if(!this._capabilities.roots)throw new Error(`Client does not support roots capability (required for ${e})`);break;case"tasks/get":case"tasks/list":case"tasks/result":case"tasks/cancel":if(!this._capabilities.tasks)throw new Error(`Client does not support tasks capability (required for ${e})`);break}}assertTaskCapability(e){var t,s;Jr((s=(t=this._serverCapabilities)==null?void 0:t.tasks)==null?void 0:s.requests,e,"Server")}assertTaskHandlerCapability(e){var t;this._capabilities&&Qr((t=this._capabilities.tasks)==null?void 0:t.requests,e,"Client")}async ping(e){return this.request({method:"ping"},G,e)}async complete(e,t){return this.request({method:"completion/complete",params:e},Dt,t)}async setLoggingLevel(e,t){return this.request({method:"logging/setLevel",params:{level:e}},G,t)}async getPrompt(e,t){return this.request({method:"prompts/get",params:e},xt,t)}async listPrompts(e,t){return this.request({method:"prompts/list",params:e},Ut,t)}async listResources(e,t){return this.request({method:"resources/list",params:e},qt,t)}async listResourceTemplates(e,t){return this.request({method:"resources/templates/list",params:e},It,t)}async readResource(e,t){return this.request({method:"resources/read",params:e},Et,t)}async subscribeResource(e,t){return this.request({method:"resources/subscribe",params:e},G,t)}async unsubscribeResource(e,t){return this.request({method:"resources/unsubscribe",params:e},G,t)}async callTool(e,t=ye,s){if(this.isToolTaskRequired(e.name))throw new f(w.InvalidRequest,`Tool "${e.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);const o=await this.request({method:"tools/call",params:e},t,s),n=this.getToolOutputValidator(e.name);if(n){if(!o.structuredContent&&!o.isError)throw new f(w.InvalidRequest,`Tool ${e.name} has an output schema but did not return structured content`);if(o.structuredContent)try{const i=n(o.structuredContent);if(!i.valid)throw new f(w.InvalidParams,`Structured content does not match the tool's output schema: ${i.errorMessage}`)}catch(i){throw i instanceof f?i:new f(w.InvalidParams,`Failed to validate structured content: ${i instanceof Error?i.message:String(i)}`)}}return o}isToolTask(e){var t,s,o,n;return(n=(o=(s=(t=this._serverCapabilities)==null?void 0:t.tasks)==null?void 0:s.requests)==null?void 0:o.tools)!=null&&n.call?this._cachedKnownTaskTools.has(e):!1}isToolTaskRequired(e){return this._cachedRequiredTaskTools.has(e)}cacheToolMetadata(e){var t;this._cachedToolOutputValidators.clear(),this._cachedKnownTaskTools.clear(),this._cachedRequiredTaskTools.clear();for(const s of e){if(s.outputSchema){const n=this._jsonSchemaValidator.getValidator(s.outputSchema);this._cachedToolOutputValidators.set(s.name,n)}const o=(t=s.execution)==null?void 0:t.taskSupport;(o==="required"||o==="optional")&&this._cachedKnownTaskTools.add(s.name),o==="required"&&this._cachedRequiredTaskTools.add(s.name)}}getToolOutputValidator(e){return this._cachedToolOutputValidators.get(e)}async listTools(e,t){const s=await this.request({method:"tools/list",params:e},At,t);return this.cacheToolMetadata(s.tools),s}_setupListChangedHandler(e,t,s,o){const n=sr.safeParse(s);if(!n.success)throw new Error(`Invalid ${e} listChanged options: ${n.error.message}`);if(typeof s.onChanged!="function")throw new Error(`Invalid ${e} listChanged options: onChanged must be a function`);const{autoRefresh:i,debounceMs:l}=n.data,{onChanged:c}=s,h=async()=>{if(!i){c(null,null);return}try{const g=await o();c(null,g)}catch(g){const _=g instanceof Error?g:new Error(String(g));c(_,null)}},m=()=>{if(l){const g=this._listChangedDebounceTimers.get(e);g&&clearTimeout(g);const _=setTimeout(h,l);this._listChangedDebounceTimers.set(e,_)}else h()};this.setNotificationHandler(t,m)}async sendRootsListChanged(){return this.notification({method:"notifications/roots/list_changed"})}}function qe(r){return r?r instanceof Headers?Object.fromEntries(r.entries()):Array.isArray(r)?Object.fromEntries(r):{...r}:{}}function Zr(r=fetch,e){return e?async(t,s)=>{const o={...e,...s,headers:s!=null&&s.headers?{...qe(e.headers),...qe(s.headers)}:e.headers};return r(t,o)}:r}const M=Xt().superRefine((r,e)=>{if(!URL.canParse(r))return e.addIssue({code:es.custom,message:"URL must be parseable",fatal:!0}),ts}).refine(r=>{const e=new URL(r);return e.protocol!=="javascript:"&&e.protocol!=="data:"&&e.protocol!=="vbscript:"},{message:"URL cannot use javascript:, data:, or vbscript: scheme"}),Gr=$({resource:a().url(),authorization_servers:u(M).optional(),jwks_uri:a().url().optional(),scopes_supported:u(a()).optional(),bearer_methods_supported:u(a()).optional(),resource_signing_alg_values_supported:u(a()).optional(),resource_name:a().optional(),resource_documentation:a().optional(),resource_policy_uri:a().url().optional(),resource_tos_uri:a().url().optional(),tls_client_certificate_bound_access_tokens:T().optional(),authorization_details_types_supported:u(a()).optional(),dpop_signing_alg_values_supported:u(a()).optional(),dpop_bound_access_tokens_required:T().optional()}),Ft=$({issuer:a(),authorization_endpoint:M,token_endpoint:M,registration_endpoint:M.optional(),scopes_supported:u(a()).optional(),response_types_supported:u(a()),response_modes_supported:u(a()).optional(),grant_types_supported:u(a()).optional(),token_endpoint_auth_methods_supported:u(a()).optional(),token_endpoint_auth_signing_alg_values_supported:u(a()).optional(),service_documentation:M.optional(),revocation_endpoint:M.optional(),revocation_endpoint_auth_methods_supported:u(a()).optional(),revocation_endpoint_auth_signing_alg_values_supported:u(a()).optional(),introspection_endpoint:a().optional(),introspection_endpoint_auth_methods_supported:u(a()).optional(),introspection_endpoint_auth_signing_alg_values_supported:u(a()).optional(),code_challenge_methods_supported:u(a()).optional(),client_id_metadata_document_supported:T().optional()}),Kr=$({issuer:a(),authorization_endpoint:M,token_endpoint:M,userinfo_endpoint:M.optional(),jwks_uri:M,registration_endpoint:M.optional(),scopes_supported:u(a()).optional(),response_types_supported:u(a()),response_modes_supported:u(a()).optional(),grant_types_supported:u(a()).optional(),acr_values_supported:u(a()).optional(),subject_types_supported:u(a()),id_token_signing_alg_values_supported:u(a()),id_token_encryption_alg_values_supported:u(a()).optional(),id_token_encryption_enc_values_supported:u(a()).optional(),userinfo_signing_alg_values_supported:u(a()).optional(),userinfo_encryption_alg_values_supported:u(a()).optional(),userinfo_encryption_enc_values_supported:u(a()).optional(),request_object_signing_alg_values_supported:u(a()).optional(),request_object_encryption_alg_values_supported:u(a()).optional(),request_object_encryption_enc_values_supported:u(a()).optional(),token_endpoint_auth_methods_supported:u(a()).optional(),token_endpoint_auth_signing_alg_values_supported:u(a()).optional(),display_values_supported:u(a()).optional(),claim_types_supported:u(a()).optional(),claims_supported:u(a()).optional(),service_documentation:a().optional(),claims_locales_supported:u(a()).optional(),ui_locales_supported:u(a()).optional(),claims_parameter_supported:T().optional(),request_parameter_supported:T().optional(),request_uri_parameter_supported:T().optional(),require_request_uri_registration:T().optional(),op_policy_uri:M.optional(),op_tos_uri:M.optional(),client_id_metadata_document_supported:T().optional()}),Yr=d({...Kr.shape,...Ft.pick({code_challenge_methods_supported:!0}).shape}),Xr=d({access_token:a(),id_token:a().optional(),token_type:a(),expires_in:ss().optional(),scope:a().optional(),refresh_token:a().optional()}).strip(),eo=d({error:a(),error_description:a().optional(),error_uri:a().optional()}),lt=M.optional().or(p("").transform(()=>{})),to=d({redirect_uris:u(M),token_endpoint_auth_method:a().optional(),grant_types:u(a()).optional(),response_types:u(a()).optional(),client_name:a().optional(),client_uri:M.optional(),logo_uri:lt,scope:a().optional(),contacts:u(a()).optional(),tos_uri:lt,policy_uri:a().optional(),jwks_uri:M.optional(),jwks:rs().optional(),software_id:a().optional(),software_version:a().optional(),software_statement:a().optional()}).strip(),so=d({client_id:a(),client_secret:a().optional(),client_id_issued_at:S().optional(),client_secret_expires_at:S().optional()}).strip(),ro=to.merge(so);d({error:a(),error_description:a().optional()}).strip();d({token:a(),token_type_hint:a().optional()}).strip();function oo(r){const e=typeof r=="string"?new URL(r):new URL(r.href);return e.hash="",e}function ao({requestedResource:r,configuredResource:e}){const t=typeof r=="string"?new URL(r):new URL(r.href),s=typeof e=="string"?new URL(e):new URL(e.href);if(t.origin!==s.origin||t.pathname.length<s.pathname.length)return!1;const o=t.pathname.endsWith("/")?t.pathname:t.pathname+"/",n=s.pathname.endsWith("/")?s.pathname:s.pathname+"/";return o.startsWith(n)}class x extends Error{constructor(e,t){super(e),this.errorUri=t,this.name=this.constructor.name}toResponseObject(){const e={error:this.errorCode,error_description:this.message};return this.errorUri&&(e.error_uri=this.errorUri),e}get errorCode(){return this.constructor.errorCode}}class Ie extends x{}Ie.errorCode="invalid_request";class pe extends x{}pe.errorCode="invalid_client";class me extends x{}me.errorCode="invalid_grant";class fe extends x{}fe.errorCode="unauthorized_client";class Ee extends x{}Ee.errorCode="unsupported_grant_type";class Pe extends x{}Pe.errorCode="invalid_scope";class Ue extends x{}Ue.errorCode="access_denied";class Y extends x{}Y.errorCode="server_error";class xe extends x{}xe.errorCode="temporarily_unavailable";class Me extends x{}Me.errorCode="unsupported_response_type";class $e extends x{}$e.errorCode="unsupported_token_type";class Ae extends x{}Ae.errorCode="invalid_token";class He extends x{}He.errorCode="method_not_allowed";class Oe extends x{}Oe.errorCode="too_many_requests";class _e extends x{}_e.errorCode="invalid_client_metadata";class Le extends x{}Le.errorCode="insufficient_scope";class Ne extends x{}Ne.errorCode="invalid_target";const no={[Ie.errorCode]:Ie,[pe.errorCode]:pe,[me.errorCode]:me,[fe.errorCode]:fe,[Ee.errorCode]:Ee,[Pe.errorCode]:Pe,[Ue.errorCode]:Ue,[Y.errorCode]:Y,[xe.errorCode]:xe,[Me.errorCode]:Me,[$e.errorCode]:$e,[Ae.errorCode]:Ae,[He.errorCode]:He,[Oe.errorCode]:Oe,[_e.errorCode]:_e,[Le.errorCode]:Le,[Ne.errorCode]:Ne};class ee extends Error{constructor(e){super(e??"Unauthorized")}}function io(r){return["client_secret_basic","client_secret_post","none"].includes(r)}const Te="code",Re="S256";function co(r,e){const t=r.client_secret!==void 0;return e.length===0?t?"client_secret_post":"none":"token_endpoint_auth_method"in r&&r.token_endpoint_auth_method&&io(r.token_endpoint_auth_method)&&e.includes(r.token_endpoint_auth_method)?r.token_endpoint_auth_method:t&&e.includes("client_secret_basic")?"client_secret_basic":t&&e.includes("client_secret_post")?"client_secret_post":e.includes("none")?"none":t?"client_secret_post":"none"}function lo(r,e,t,s){const{client_id:o,client_secret:n}=e;switch(r){case"client_secret_basic":uo(o,n,t);return;case"client_secret_post":ho(o,n,s);return;case"none":po(o,s);return;default:throw new Error(`Unsupported client authentication method: ${r}`)}}function uo(r,e,t){if(!e)throw new Error("client_secret_basic authentication requires a client_secret");const s=btoa(`${r}:${e}`);t.set("Authorization",`Basic ${s}`)}function ho(r,e,t){t.set("client_id",r),e&&t.set("client_secret",e)}function po(r,e){e.set("client_id",r)}async function Wt(r){const e=r instanceof Response?r.status:void 0,t=r instanceof Response?await r.text():r;try{const s=eo.parse(JSON.parse(t)),{error:o,error_description:n,error_uri:i}=s,l=no[o]||Y;return new l(n||"",i)}catch(s){const o=`${e?`HTTP ${e}: `:""}Invalid OAuth error response: ${s}. Raw body: ${t}`;return new Y(o)}}async function ve(r,e){var t,s;try{return await Ce(r,e)}catch(o){if(o instanceof pe||o instanceof fe)return await((t=r.invalidateCredentials)==null?void 0:t.call(r,"all")),await Ce(r,e);if(o instanceof me)return await((s=r.invalidateCredentials)==null?void 0:s.call(r,"tokens")),await Ce(r,e);throw o}}async function Ce(r,{serverUrl:e,authorizationCode:t,scope:s,resourceMetadataUrl:o,fetchFn:n}){var U,y;let i,l;try{i=await _o(e,{resourceMetadataUrl:o},n),i.authorization_servers&&i.authorization_servers.length>0&&(l=i.authorization_servers[0])}catch{}l||(l=new URL("/",e));const c=await fo(e,r,i),h=await yo(l,{fetchFn:n});let m=await Promise.resolve(r.clientInformation());if(!m){if(t!==void 0)throw new Error("Existing OAuth client information is required when exchanging an authorization code");const q=(h==null?void 0:h.client_id_metadata_document_supported)===!0,N=r.clientMetadataUrl;if(N&&!mo(N))throw new _e(`clientMetadataUrl must be a valid HTTPS URL with a non-root pathname, got: ${N}`);if(q&&N)m={client_id:N},await((U=r.saveClientInformation)==null?void 0:U.call(r,m));else{if(!r.saveClientInformation)throw new Error("OAuth client information must be saveable for dynamic registration");const L=await bo(l,{metadata:h,clientMetadata:r.clientMetadata,fetchFn:n});await r.saveClientInformation(L),m=L}}const g=!r.redirectUrl;if(t!==void 0||g){const q=await Co(r,l,{metadata:h,resource:c,authorizationCode:t,fetchFn:n});return await r.saveTokens(q),"AUTHORIZED"}const _=await r.tokens();if(_!=null&&_.refresh_token)try{const q=await vo(l,{metadata:h,clientInformation:m,refreshToken:_.refresh_token,resource:c,addClientAuthentication:r.addClientAuthentication,fetchFn:n});return await r.saveTokens(q),"AUTHORIZED"}catch(q){if(!(!(q instanceof x)||q instanceof Y))throw q}const C=r.state?await r.state():void 0,{authorizationUrl:k,codeVerifier:R}=await To(l,{metadata:h,clientInformation:m,state:C,redirectUrl:r.redirectUrl,scope:s||((y=i==null?void 0:i.scopes_supported)==null?void 0:y.join(" "))||r.clientMetadata.scope,resource:c});return await r.saveCodeVerifier(R),await r.redirectToAuthorization(k),"REDIRECT"}function mo(r){if(!r)return!1;try{const e=new URL(r);return e.protocol==="https:"&&e.pathname!=="/"}catch{return!1}}async function fo(r,e,t){const s=oo(r);if(e.validateResourceURL)return await e.validateResourceURL(s,t==null?void 0:t.resource);if(t){if(!ao({requestedResource:s,configuredResource:t.resource}))throw new Error(`Protected resource ${t.resource} does not match expected ${s} (or origin)`);return new URL(t.resource)}}function ut(r){const e=r.headers.get("WWW-Authenticate");if(!e)return{};const[t,s]=e.split(" ");if(t.toLowerCase()!=="bearer"||!s)return{};const o=be(r,"resource_metadata")||void 0;let n;if(o)try{n=new URL(o)}catch{}const i=be(r,"scope")||void 0,l=be(r,"error")||void 0;return{resourceMetadataUrl:n,scope:i,error:l}}function be(r,e){const t=r.headers.get("WWW-Authenticate");if(!t)return null;const s=new RegExp(`${e}=(?:"([^"]+)"|([^\\s,]+))`),o=t.match(s);return o?o[1]||o[2]:null}async function _o(r,e,t=fetch){var o,n;const s=await So(r,"oauth-protected-resource",t,{protocolVersion:e==null?void 0:e.protocolVersion,metadataUrl:e==null?void 0:e.resourceMetadataUrl});if(!s||s.status===404)throw await((o=s==null?void 0:s.body)==null?void 0:o.cancel()),new Error("Resource server does not implement OAuth 2.0 Protected Resource Metadata.");if(!s.ok)throw await((n=s.body)==null?void 0:n.cancel()),new Error(`HTTP ${s.status} trying to load well-known OAuth protected resource metadata.`);return Gr.parse(await s.json())}async function ot(r,e,t=fetch){try{return await t(r,{headers:e})}catch(s){if(s instanceof TypeError)return e?ot(r,void 0,t):void 0;throw s}}function go(r,e="",t={}){return e.endsWith("/")&&(e=e.slice(0,-1)),t.prependPathname?`${e}/.well-known/${r}`:`/.well-known/${r}${e}`}async function dt(r,e,t=fetch){return await ot(r,{"MCP-Protocol-Version":e},t)}function wo(r,e){return!r||r.status>=400&&r.status<500&&e!=="/"}async function So(r,e,t,s){const o=new URL(r),n=(s==null?void 0:s.protocolVersion)??we;let i;if(s!=null&&s.metadataUrl)i=new URL(s.metadataUrl);else{const c=go(e,o.pathname);i=new URL(c,(s==null?void 0:s.metadataServerUrl)??o),i.search=o.search}let l=await dt(i,n,t);if(!(s!=null&&s.metadataUrl)&&wo(l,o.pathname)){const c=new URL(`/.well-known/${e}`,o);l=await dt(c,n,t)}return l}function ko(r){const e=typeof r=="string"?new URL(r):r,t=e.pathname!=="/",s=[];if(!t)return s.push({url:new URL("/.well-known/oauth-authorization-server",e.origin),type:"oauth"}),s.push({url:new URL("/.well-known/openid-configuration",e.origin),type:"oidc"}),s;let o=e.pathname;return o.endsWith("/")&&(o=o.slice(0,-1)),s.push({url:new URL(`/.well-known/oauth-authorization-server${o}`,e.origin),type:"oauth"}),s.push({url:new URL(`/.well-known/openid-configuration${o}`,e.origin),type:"oidc"}),s.push({url:new URL(`${o}/.well-known/openid-configuration`,e.origin),type:"oidc"}),s}async function yo(r,{fetchFn:e=fetch,protocolVersion:t=we}={}){var n;const s={"MCP-Protocol-Version":t,Accept:"application/json"},o=ko(r);for(const{url:i,type:l}of o){const c=await ot(i,s,e);if(c){if(!c.ok){if(await((n=c.body)==null?void 0:n.cancel()),c.status>=400&&c.status<500)continue;throw new Error(`HTTP ${c.status} trying to load ${l==="oauth"?"OAuth":"OpenID provider"} metadata from ${i}`)}return l==="oauth"?Ft.parse(await c.json()):Yr.parse(await c.json())}}}async function To(r,{metadata:e,clientInformation:t,redirectUrl:s,scope:o,state:n,resource:i}){let l;if(e){if(l=new URL(e.authorization_endpoint),!e.response_types_supported.includes(Te))throw new Error(`Incompatible auth server: does not support response type ${Te}`);if(e.code_challenge_methods_supported&&!e.code_challenge_methods_supported.includes(Re))throw new Error(`Incompatible auth server: does not support code challenge method ${Re}`)}else l=new URL("/authorize",r);const c=await os(),h=c.code_verifier,m=c.code_challenge;return l.searchParams.set("response_type",Te),l.searchParams.set("client_id",t.client_id),l.searchParams.set("code_challenge",m),l.searchParams.set("code_challenge_method",Re),l.searchParams.set("redirect_uri",String(s)),n&&l.searchParams.set("state",n),o&&l.searchParams.set("scope",o),o!=null&&o.includes("offline_access")&&l.searchParams.append("prompt","consent"),i&&l.searchParams.set("resource",i.href),{authorizationUrl:l,codeVerifier:h}}function Ro(r,e,t){return new URLSearchParams({grant_type:"authorization_code",code:r,code_verifier:e,redirect_uri:String(t)})}async function Jt(r,{metadata:e,tokenRequestParams:t,clientInformation:s,addClientAuthentication:o,resource:n,fetchFn:i}){const l=e!=null&&e.token_endpoint?new URL(e.token_endpoint):new URL("/token",r),c=new Headers({"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"});if(n&&t.set("resource",n.href),o)await o(c,t,l,e);else if(s){const m=(e==null?void 0:e.token_endpoint_auth_methods_supported)??[],g=co(s,m);lo(g,s,c,t)}const h=await(i??fetch)(l,{method:"POST",headers:c,body:t});if(!h.ok)throw await Wt(h);return Xr.parse(await h.json())}async function vo(r,{metadata:e,clientInformation:t,refreshToken:s,resource:o,addClientAuthentication:n,fetchFn:i}){const l=new URLSearchParams({grant_type:"refresh_token",refresh_token:s}),c=await Jt(r,{metadata:e,tokenRequestParams:l,clientInformation:t,addClientAuthentication:n,resource:o,fetchFn:i});return{refresh_token:s,...c}}async function Co(r,e,{metadata:t,resource:s,authorizationCode:o,fetchFn:n}={}){const i=r.clientMetadata.scope;let l;if(r.prepareTokenRequest&&(l=await r.prepareTokenRequest(i)),!l){if(!o)throw new Error("Either provider.prepareTokenRequest() or authorizationCode is required");if(!r.redirectUrl)throw new Error("redirectUrl is required for authorization_code flow");const h=await r.codeVerifier();l=Ro(o,h,r.redirectUrl)}const c=await r.clientInformation();return Jt(e,{metadata:t,tokenRequestParams:l,clientInformation:c??void 0,addClientAuthentication:r.addClientAuthentication,resource:s,fetchFn:n})}async function bo(r,{metadata:e,clientMetadata:t,fetchFn:s}){let o;if(e){if(!e.registration_endpoint)throw new Error("Incompatible auth server: does not support dynamic client registration");o=new URL(e.registration_endpoint)}else o=new URL("/register",r);const n=await(s??fetch)(o,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});if(!n.ok)throw await Wt(n);return ro.parse(await n.json())}class qo extends Error{constructor(e,t,s){super(`SSE error: ${t}`),this.code=e,this.event=s}}class Po{constructor(e,t){this._url=e,this._resourceMetadataUrl=void 0,this._scope=void 0,this._eventSourceInit=t==null?void 0:t.eventSourceInit,this._requestInit=t==null?void 0:t.requestInit,this._authProvider=t==null?void 0:t.authProvider,this._fetch=t==null?void 0:t.fetch,this._fetchWithInit=Zr(t==null?void 0:t.fetch,t==null?void 0:t.requestInit)}async _authThenStart(){var t;if(!this._authProvider)throw new ee("No auth provider");let e;try{e=await ve(this._authProvider,{serverUrl:this._url,resourceMetadataUrl:this._resourceMetadataUrl,scope:this._scope,fetchFn:this._fetchWithInit})}catch(s){throw(t=this.onerror)==null||t.call(this,s),s}if(e!=="AUTHORIZED")throw new ee;return await this._startOrAuth()}async _commonHeaders(){var s;const e={};if(this._authProvider){const o=await this._authProvider.tokens();o&&(e.Authorization=`Bearer ${o.access_token}`)}this._protocolVersion&&(e["mcp-protocol-version"]=this._protocolVersion);const t=qe((s=this._requestInit)==null?void 0:s.headers);return new Headers({...e,...t})}_startOrAuth(){var t;const e=((t=this==null?void 0:this._eventSourceInit)==null?void 0:t.fetch)??this._fetch??fetch;return new Promise((s,o)=>{this._eventSource=new as(this._url.href,{...this._eventSourceInit,fetch:async(n,i)=>{const l=await this._commonHeaders();l.set("Accept","text/event-stream");const c=await e(n,{...i,headers:l});if(c.status===401&&c.headers.has("www-authenticate")){const{resourceMetadataUrl:h,scope:m}=ut(c);this._resourceMetadataUrl=h,this._scope=m}return c}}),this._abortController=new AbortController,this._eventSource.onerror=n=>{var l;if(n.code===401&&this._authProvider){this._authThenStart().then(s,o);return}const i=new qo(n.code,n.message,n);o(i),(l=this.onerror)==null||l.call(this,i)},this._eventSource.onopen=()=>{},this._eventSource.addEventListener("endpoint",n=>{var l;const i=n;try{if(this._endpoint=new URL(i.data,this._url),this._endpoint.origin!==this._url.origin)throw new Error(`Endpoint origin does not match connection origin: ${this._endpoint.origin}`)}catch(c){o(c),(l=this.onerror)==null||l.call(this,c),this.close();return}s()}),this._eventSource.onmessage=n=>{var c,h;const i=n;let l;try{l=ps.parse(JSON.parse(i.data))}catch(m){(c=this.onerror)==null||c.call(this,m);return}(h=this.onmessage)==null||h.call(this,l)}})}async start(){if(this._eventSource)throw new Error("SSEClientTransport already started! If using Client class, note that connect() calls start() automatically.");return await this._startOrAuth()}async finishAuth(e){if(!this._authProvider)throw new ee("No auth provider");if(await ve(this._authProvider,{serverUrl:this._url,authorizationCode:e,resourceMetadataUrl:this._resourceMetadataUrl,scope:this._scope,fetchFn:this._fetchWithInit})!=="AUTHORIZED")throw new ee("Failed to authorize")}async close(){var e,t,s;(e=this._abortController)==null||e.abort(),(t=this._eventSource)==null||t.close(),(s=this.onclose)==null||s.call(this)}async send(e){var t,s,o;if(!this._endpoint)throw new Error("Not connected");try{const n=await this._commonHeaders();n.set("content-type","application/json");const i={...this._requestInit,method:"POST",headers:n,body:JSON.stringify(e),signal:(t=this._abortController)==null?void 0:t.signal},l=await(this._fetch??fetch)(this._endpoint,i);if(!l.ok){const c=await l.text().catch(()=>null);if(l.status===401&&this._authProvider){const{resourceMetadataUrl:h,scope:m}=ut(l);if(this._resourceMetadataUrl=h,this._scope=m,await ve(this._authProvider,{serverUrl:this._url,resourceMetadataUrl:this._resourceMetadataUrl,scope:this._scope,fetchFn:this._fetchWithInit})!=="AUTHORIZED")throw new ee;return this.send(e)}throw new Error(`Error POSTing to endpoint (HTTP ${l.status}): ${c}`)}await((s=l.body)==null?void 0:s.cancel())}catch(n){throw(o=this.onerror)==null||o.call(this,n),n}}setProtocolVersion(e){this._protocolVersion=e}}export{Eo as C,Po as S};
