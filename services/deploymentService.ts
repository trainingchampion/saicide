/**
 * Deployment Service for Netlify and Vercel
 * Handles real deployments using platform APIs
 */

export interface DeploymentConfig {
    projectName: string;
    files: { path: string; content: string }[];
    framework?: 'vite' | 'next' | 'react' | 'static';
}

export interface DeploymentResult {
    success: boolean;
    url?: string;
    deployId?: string;
    error?: string;
}

export interface DeploymentProgress {
    progress: number;
    status: string;
    log?: string;
}

// Generate HTML/JS/CSS bundle from AppPlan
const generateDeployableBundle = (appPlan: any): { path: string; content: string }[] => {
    const files: { path: string; content: string }[] = [];
    
    // Generate index.html
    const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${appPlan.name || 'SAI App'}</title>
    <meta name="description" content="${appPlan.description || 'Generated by SAI IDE'}">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, -apple-system, sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="module" src="/app.js"></script>
</body>
</html>`;
    
    files.push({ path: 'index.html', content: htmlContent });
    
    // Generate app.js from components
    let appCode = '';
    if (appPlan.components) {
        appCode = appPlan.components.map((c: any) => c.code || '').join('\n\n');
    } else if (appPlan.code) {
        appCode = appPlan.code;
    } else {
        appCode = `
document.getElementById('root').innerHTML = \`
<div class="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900 flex items-center justify-center">
    <div class="text-center text-white p-8">
        <h1 class="text-5xl font-bold mb-4">${appPlan.name || 'SAI App'}</h1>
        <p class="text-xl opacity-80 mb-8">${appPlan.description || 'Built with SAI IDE'}</p>
        <div class="inline-flex items-center gap-2 px-6 py-3 bg-white/10 rounded-full backdrop-blur">
            <span class="w-3 h-3 bg-green-400 rounded-full animate-pulse"></span>
            <span>Deployed Successfully</span>
        </div>
    </div>
</div>
\`;
`;
    }
    
    files.push({ path: 'app.js', content: appCode });
    
    // Add netlify.toml for configuration
    files.push({
        path: 'netlify.toml',
        content: `[build]
  publish = "."

[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-XSS-Protection = "1; mode=block"
`
    });
    
    // Add vercel.json for configuration  
    files.push({
        path: 'vercel.json',
        content: JSON.stringify({
            version: 2,
            builds: [{ src: "**/*", use: "@vercel/static" }],
            routes: [{ handle: "filesystem" }, { src: "/(.*)", dest: "/index.html" }]
        }, null, 2)
    });
    
    return files;
};

// Deploy to Netlify using their API
export const deployToNetlify = async (
    config: DeploymentConfig,
    onProgress: (progress: DeploymentProgress) => void,
    accessToken?: string
): Promise<DeploymentResult> => {
    const files = config.files.length > 0 ? config.files : generateDeployableBundle(config);
    
    onProgress({ progress: 5, status: 'Preparing deployment...', log: 'ðŸš€ Initializing Netlify deployment...' });
    
    try {
        // Create file digests
        const fileDigests: { [path: string]: string } = {};
        const fileContents: { [hash: string]: string } = {};
        
        for (const file of files) {
            // Create a simple hash for the content
            const encoder = new TextEncoder();
            const data = encoder.encode(file.content);
            const hashBuffer = await crypto.subtle.digest('SHA-1', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            
            fileDigests[`/${file.path}`] = hash;
            fileContents[hash] = file.content;
        }
        
        onProgress({ progress: 15, status: 'Computing file hashes...', log: `ðŸ“¦ Prepared ${files.length} files for upload` });
        
        // If no access token, use Netlify's anonymous deploy API
        if (!accessToken) {
            onProgress({ progress: 25, status: 'Creating anonymous deploy...', log: 'ðŸŒ Using Netlify Drop API for deployment' });
            
            // Create a deploy using Netlify's public API
            const createResponse = await fetch('https://api.netlify.com/api/v1/sites', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: config.projectName + '-' + Math.random().toString(36).substring(2, 8),
                })
            });
            
            if (!createResponse.ok) {
                // Fallback: Create deploy via form data (Netlify Drop style)
                onProgress({ progress: 35, status: 'Preparing bundle...', log: 'ðŸ“¤ Creating deployment bundle...' });
                
                // Create a zip-like bundle
                const boundary = '----NetlifyFormBoundary' + Math.random().toString(36).substring(2);
                let body = '';
                
                for (const file of files) {
                    body += `--${boundary}\r\n`;
                    body += `Content-Disposition: form-data; name="files[]"; filename="${file.path}"\r\n`;
                    body += `Content-Type: ${file.path.endsWith('.html') ? 'text/html' : file.path.endsWith('.js') ? 'application/javascript' : 'text/plain'}\r\n\r\n`;
                    body += file.content + '\r\n';
                }
                body += `--${boundary}--\r\n`;
                
                onProgress({ progress: 50, status: 'Uploading to Netlify...', log: 'â˜ï¸ Uploading files to Netlify CDN...' });
                
                // Use the deploy endpoint
                const deployResponse = await fetch('/api/deploy/netlify', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projectName: config.projectName,
                        files: files.map(f => ({ path: f.path, content: f.content }))
                    })
                });
                
                if (deployResponse.ok) {
                    const result = await deployResponse.json();
                    onProgress({ progress: 100, status: 'Deployment complete!', log: `âœ… Deployed to ${result.url}` });
                    return { success: true, url: result.url, deployId: result.deployId };
                }
            }
            
            // Fallback to generating a downloadable package
            onProgress({ progress: 60, status: 'Generating deployment package...', log: 'ðŸ“¦ Creating downloadable bundle...' });
            
            // Create blob URL for download
            const htmlFile = files.find(f => f.path === 'index.html');
            const jsFile = files.find(f => f.path === 'app.js');
            
            if (htmlFile && jsFile) {
                // Inline the JS into HTML for single-file deployment
                const inlinedHtml = htmlFile.content.replace(
                    '<script type="module" src="/app.js"></script>',
                    `<script type="module">${jsFile.content}</script>`
                );
                
                const blob = new Blob([inlinedHtml], { type: 'text/html' });
                const blobUrl = URL.createObjectURL(blob);
                
                onProgress({ progress: 80, status: 'Opening Netlify Drop...', log: 'ðŸŒ Opening Netlify Drop interface...' });
                
                // Open Netlify Drop in a new tab
                const netlifyDropUrl = 'https://app.netlify.com/drop';
                window.open(netlifyDropUrl, '_blank');
                
                // Also trigger download of the HTML file
                const link = document.createElement('a');
                link.href = blobUrl;
                link.download = `${config.projectName}.html`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                onProgress({ 
                    progress: 100, 
                    status: 'Ready for deployment!', 
                    log: 'âœ… Downloaded! Drag the file to Netlify Drop to deploy' 
                });
                
                return { 
                    success: true, 
                    url: netlifyDropUrl,
                    deployId: 'manual-drop'
                };
            }
        } else {
            // Use authenticated API
            onProgress({ progress: 30, status: 'Authenticating...', log: 'ðŸ” Authenticating with Netlify API...' });
            
            // Create site
            const siteResponse = await fetch('https://api.netlify.com/api/v1/sites', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name: config.projectName })
            });
            
            if (!siteResponse.ok) {
                const error = await siteResponse.json();
                throw new Error(error.message || 'Failed to create site');
            }
            
            const site = await siteResponse.json();
            onProgress({ progress: 50, status: 'Site created...', log: `ðŸ“ Created site: ${site.name}` });
            
            // Create deploy
            const deployResponse = await fetch(`https://api.netlify.com/api/v1/sites/${site.id}/deploys`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ files: fileDigests })
            });
            
            if (!deployResponse.ok) {
                throw new Error('Failed to create deploy');
            }
            
            const deploy = await deployResponse.json();
            onProgress({ progress: 70, status: 'Uploading files...', log: 'ðŸ“¤ Uploading files...' });
            
            // Upload required files
            for (const hash of deploy.required || []) {
                const content = fileContents[hash];
                if (content) {
                    await fetch(`https://api.netlify.com/api/v1/deploys/${deploy.id}/files/${hash}`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`,
                            'Content-Type': 'application/octet-stream',
                        },
                        body: content
                    });
                }
            }
            
            onProgress({ progress: 90, status: 'Finalizing...', log: 'âš¡ Propagating to CDN...' });
            
            // Wait for deploy to be ready
            await new Promise(r => setTimeout(r, 2000));
            
            onProgress({ progress: 100, status: 'Deployed!', log: `âœ… Live at ${site.ssl_url}` });
            
            return { success: true, url: site.ssl_url, deployId: deploy.id };
        }
        
        throw new Error('Deployment method not available');
        
    } catch (error: any) {
        onProgress({ progress: 0, status: 'Failed', log: `âŒ Error: ${error.message}` });
        return { success: false, error: error.message };
    }
};

// Deploy to Vercel using their API
export const deployToVercel = async (
    config: DeploymentConfig,
    onProgress: (progress: DeploymentProgress) => void,
    accessToken?: string
): Promise<DeploymentResult> => {
    const files = config.files.length > 0 ? config.files : generateDeployableBundle(config);
    
    onProgress({ progress: 5, status: 'Preparing deployment...', log: 'â–² Initializing Vercel deployment...' });
    
    try {
        if (!accessToken) {
            onProgress({ progress: 20, status: 'Preparing bundle...', log: 'ðŸ“¦ Creating deployment bundle...' });
            
            // Try our backend API first
            const deployResponse = await fetch('/api/deploy/vercel', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    projectName: config.projectName,
                    files: files.map(f => ({ path: f.path, content: f.content }))
                })
            });
            
            if (deployResponse.ok) {
                const result = await deployResponse.json();
                onProgress({ progress: 100, status: 'Deployed!', log: `âœ… Deployed to ${result.url}` });
                return { success: true, url: result.url, deployId: result.deployId };
            }
            
            // Fallback: Open Vercel import with GitHub
            onProgress({ progress: 50, status: 'Opening Vercel...', log: 'ðŸŒ Opening Vercel deployment interface...' });
            
            // Create downloadable package
            const htmlFile = files.find(f => f.path === 'index.html');
            const jsFile = files.find(f => f.path === 'app.js');
            
            if (htmlFile && jsFile) {
                const inlinedHtml = htmlFile.content.replace(
                    '<script type="module" src="/app.js"></script>',
                    `<script type="module">${jsFile.content}</script>`
                );
                
                const blob = new Blob([inlinedHtml], { type: 'text/html' });
                const blobUrl = URL.createObjectURL(blob);
                
                // Download the file
                const link = document.createElement('a');
                link.href = blobUrl;
                link.download = `${config.projectName}.html`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Open Vercel new project page
                window.open('https://vercel.com/new', '_blank');
                
                onProgress({ 
                    progress: 100, 
                    status: 'Ready for import!', 
                    log: 'âœ… Downloaded! Import to Vercel or connect your GitHub repo' 
                });
                
                return { 
                    success: true, 
                    url: 'https://vercel.com/new',
                    deployId: 'manual-import'
                };
            }
        } else {
            // Authenticated Vercel deployment
            onProgress({ progress: 20, status: 'Authenticating...', log: 'ðŸ” Authenticating with Vercel...' });
            
            // Create deployment using Vercel API v13
            const vercelFiles = files.map(f => ({
                file: f.path,
                data: btoa(unescape(encodeURIComponent(f.content))), // Base64 encode
            }));
            
            const deployResponse = await fetch('https://api.vercel.com/v13/deployments', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: config.projectName,
                    files: vercelFiles,
                    projectSettings: {
                        framework: null, // Static
                    }
                })
            });
            
            if (!deployResponse.ok) {
                const error = await deployResponse.json();
                throw new Error(error.error?.message || 'Vercel deployment failed');
            }
            
            const deploy = await deployResponse.json();
            onProgress({ progress: 60, status: 'Building...', log: 'ðŸ”¨ Building project...' });
            
            // Poll for deployment status
            let status = deploy.readyState;
            let attempts = 0;
            
            while (status !== 'READY' && status !== 'ERROR' && attempts < 30) {
                await new Promise(r => setTimeout(r, 2000));
                
                const statusResponse = await fetch(`https://api.vercel.com/v13/deployments/${deploy.id}`, {
                    headers: { 'Authorization': `Bearer ${accessToken}` }
                });
                
                const statusData = await statusResponse.json();
                status = statusData.readyState;
                attempts++;
                
                onProgress({ 
                    progress: 60 + Math.min(attempts * 3, 35), 
                    status: `Building... (${status})`, 
                    log: `â³ Build status: ${status}` 
                });
            }
            
            if (status === 'READY') {
                const url = `https://${deploy.url}`;
                onProgress({ progress: 100, status: 'Deployed!', log: `âœ… Live at ${url}` });
                return { success: true, url, deployId: deploy.id };
            } else {
                throw new Error(`Deployment failed with status: ${status}`);
            }
        }
        
        throw new Error('Deployment method not available');
        
    } catch (error: any) {
        onProgress({ progress: 0, status: 'Failed', log: `âŒ Error: ${error.message}` });
        return { success: false, error: error.message };
    }
};

// Get stored tokens
export const getNetlifyToken = (): string | null => {
    return localStorage.getItem('sai_netlify_token');
};

export const getVercelToken = (): string | null => {
    return localStorage.getItem('sai_vercel_token');
};

// Store tokens
export const setNetlifyToken = (token: string) => {
    localStorage.setItem('sai_netlify_token', token);
};

export const setVercelToken = (token: string) => {
    localStorage.setItem('sai_vercel_token', token);
};

export default {
    deployToNetlify,
    deployToVercel,
    getNetlifyToken,
    getVercelToken,
    setNetlifyToken,
    setVercelToken,
    generateDeployableBundle
};
